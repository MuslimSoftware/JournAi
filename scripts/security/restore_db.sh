#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  restore_db.sh --backup-dir <dir> --target-db <db_path> [--allow-overwrite]

Description:
  Restores a database from a backup directory generated by backup_db.sh.
  If target exists, restore is blocked unless --allow-overwrite is set.
  When overwrite is allowed, a pre-restore snapshot is created first.
EOF
}

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing required command: $1" >&2
    exit 1
  fi
}

checksum_file() {
  shasum -a 256 "$1" | awk '{ print $1 }'
}

read_manifest_value() {
  local manifest="$1"
  local key="$2"
  awk -F= -v target="$key" '$1 == target { sub(/^[^=]*=/, "", $0); print $0 }' "$manifest" | head -n 1
}

BACKUP_DIR=""
TARGET_DB=""
ALLOW_OVERWRITE=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --backup-dir)
      BACKUP_DIR="${2:-}"
      shift 2
      ;;
    --target-db)
      TARGET_DB="${2:-}"
      shift 2
      ;;
    --allow-overwrite)
      ALLOW_OVERWRITE=1
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ -z "$BACKUP_DIR" || -z "$TARGET_DB" ]]; then
  echo "Error: --backup-dir and --target-db are required." >&2
  usage
  exit 1
fi

require_cmd sqlite3
require_cmd shasum

manifest_path="$BACKUP_DIR/manifest.txt"
if [[ ! -f "$manifest_path" ]]; then
  echo "Error: backup manifest not found at $manifest_path" >&2
  exit 1
fi

backup_db_base="$(read_manifest_value "$manifest_path" "backup_db_basename")"
backup_db_path="$BACKUP_DIR/$backup_db_base"
if [[ ! -f "$backup_db_path" ]]; then
  echo "Error: backup DB file not found at $backup_db_path" >&2
  exit 1
fi

mkdir -p "$(dirname "$TARGET_DB")"

pre_restore_path=""
if [[ -f "$TARGET_DB" ]]; then
  if [[ "$ALLOW_OVERWRITE" -ne 1 ]]; then
    echo "Error: target DB exists. Re-run with --allow-overwrite." >&2
    exit 1
  fi

  timestamp="$(date -u +%Y%m%dT%H%M%SZ)"
  pre_restore_path="${TARGET_DB}.pre-restore.${timestamp}"
  cp "$TARGET_DB" "$pre_restore_path"

  if [[ -f "${TARGET_DB}-wal" ]]; then
    cp "${TARGET_DB}-wal" "${pre_restore_path}-wal"
  fi
  if [[ -f "${TARGET_DB}-shm" ]]; then
    cp "${TARGET_DB}-shm" "${pre_restore_path}-shm"
  fi
fi

rm -f "${TARGET_DB}-wal" "${TARGET_DB}-shm"
cp "$backup_db_path" "$TARGET_DB"

for suffix in -wal -shm; do
  if [[ -f "${backup_db_path}${suffix}" ]]; then
    cp "${backup_db_path}${suffix}" "${TARGET_DB}${suffix}"
  fi
done

expected_checksum="$(checksum_file "$backup_db_path")"
actual_checksum="$(checksum_file "$TARGET_DB")"
if [[ "$expected_checksum" != "$actual_checksum" ]]; then
  echo "Error: checksum mismatch after restore." >&2
  exit 1
fi

integrity_result="$(sqlite3 "$TARGET_DB" "PRAGMA quick_check;" | tr -d '\r\n')"
if [[ "$integrity_result" != "ok" ]]; then
  echo "Error: restore quick_check failed: $integrity_result" >&2
  exit 1
fi

echo "target_db=$TARGET_DB"
echo "restored_from=$backup_db_path"
if [[ -n "$pre_restore_path" ]]; then
  echo "pre_restore_snapshot=$pre_restore_path"
fi
echo "sha256=$actual_checksum"
